# strings; string.h; fgets()
## strings
Στην C τα strings ειναι char arrays και μπορούν να γίνουν printed στην οθόνη με
τη χρήση του `%s`
```c
char s1[] = {'h', 'e', 'l', 'l', 'o'};
printf("%s\n", s1);
```
```
hello
```
Θα μπορούσαμε να ορίσουμε πιο γρήγορα ένα string ως εξής:
```c
char s2[] = "hello";
```
Παρατηρήστε ότι σε αυτή τη περίπτωση χρησιμοποιήθηκαν διπλά εισαγωγικά `""`
αντί για μονά `''`. Τα μονά εισαγωγικά περιέχουν **πάντα 1 char**, ενώ τα
διπλά εισαγωγικά περιέχουν **πάντα ένα string**.

Μία ακόμη διαφορά είναι ότι το μέγεθος του `s1` είναι `5 * 1 = 5` bytes ενώ το
μέγεθος του `s2` είναι `6 * 1 = 6` bytes, όπου το `5` γίνεται `6` γιατί
αναπαριστά το μέγεθος του τερματικού χαρακτήρα `\0`. Ο τερματικός χαρακτήρας
υποδηλώνει πού τελειώνει ένα string. Θα μπορούσαμε να εισάγουμε το `\0` πιο
νωρίς σε ένα string για να το τερματίσουμε στη μέση του.
```c
char s3[] = "Hello World!";
printf("whole string: %s\n", s3);
s3[5] = '\0';
printf("truncated string: %s\n", s3);
```
```
whole string: Hello World!
truncated string: Hello
```

Εάν δεν αρχικοποιήσουμε το string με κάποιον από τους δύο τρόπους κατά τον
ορισμό του, δεν θα μπορούμε πιο μετά στον κώδικα να του δώσουμε μια τιμή με τη
χρήση του γρήγορου τρόπου:
```c
char s4[5];
s4 = "hello";  // raises error
```
```
error: assignment to expression with array type
```
Ο πρώτος προφανής τρόπος για να αρχικοποιήσουμε ένα ήδη ορισμένο string είναι
να γεμίσουμε τις τιμές του σαν να είναι πίνακας.
```c
char s[5];
s[0] = 'h';
s[1] = 'e';
s[2] = 'l';
s[3] = 'l';
s[4] = 'o';
printf("%s\n", s);
```
```
hello
```
Αλλά, επειδή αυτός ο τρόπος είναι πολύ αργός και καθόλου πρακτικός, γεννάται η
ανάγκη ύπαρξης μιας συνάρτησης που θα κάνει αυτή τη δουλειά αυτόματα.

## string.h
Η `string.h` είναι μια βιβλιοθήκη που περιέχει χρήσιμες συναρτήσεις που
διευκολύνουν την διαχείρηση strings. Για να μπορέσουμε να τις χρησιμοποιήσουμε
πρέπει να προσθέσουμε `#include <string.h>` στην αρχή του κώδικα.

### strcpy
Για να αντιγράψουμε την τιμή `hello` στη μεταβλητή `s` μπορούμε να
χρησιμοποιήσουμε τη συνάρτηση `strcpy()` - string copy. Ωστόσο πρέπει να
προσέξουμε το εξής: Η `strcpy` κάνει την αντιγραφή των χαρακτήρων έναν προς
έναν, αλλά στο τέλος γράφει και τον τερματικό χαρακτήρα `\0` και γι' αυτό θα
χρειαστούμε η μεταβλητή να είναι μεγέθους 6 bytes αντί για 5, δηλαδή όσο το
μήκος του string που θέλουμε να αντιγράψουμε συν 1.
```c
char s[6];
strcpy(s, "hello");
printf("%s\n", s);
```
```
hello
```
H `strcpy` μπορεί να πάρει ως δεύτερο όρισμα και μια άλλη μεταβλητή:
`strcpy(dest, src)`. Στην ουσία, αντιγράφει τα δεδομένα της πηγής `src` στον
προορισμό `dest`.

### strcmp
Η `strcmp(str1, str2)` συγκρίνει αλφαβητικά δύο strings `str1` και `str2` και
εάν είναι ίδια επιστρέφει `0`.
```c
int comparison;
comparison = strcmp("hello", "hello");
printf("%d\n", comparison);
```
```
0
```
Μπορούμε να συμπτύξουμε των κώδικα σε μια γραμμή:
```c
printf("%d\n", strcmp("hello", "hello"))
```
Όταν τα strings είναι διαφορετικά, ο αριθμός που επιστρέφει η συνάρτηση μας
δίνει πληροφορίες για το πιο από τα δύο προηγείται αλφαβητικά.
```c
printf("%d\n", strcmp("aaa", "bbb"));
```
```
-1
```
To αποτέλεσμα είναι αρνητικό όταν προηγείται το πρώτο string και θετικό όταν
προηγείται το δεύτερο.

## fgets()
Με την `fgets` μπορούμε να λάβουμε input από τον χρήστη. Οι παράμετροι που
δέχεται είναι τρεις:

`char*`: Η μεταβλητή στην οποία θα αποθηκευτεί το input.

`int`: Ο μέγιστος αριθμός χαρακτήρων που θα διαβάσει. Η `fgets` μπορεί να
διαβάσει και λιγότερους χαρακτήρες αν ο χρήστης πατήσει πιο νωρίς `Enter`.

`FILE*`: Το αρχείο που θα διαβάσει. Εάν θέλουμε να διαβάσει το input του χρήστη
τότε απλά βάζουμε `stdin`. Θα δούμε ότι η `fgets` μπορεί να διαβάσει και αρχεία
κειμένου.
```c
char input[5];
fgets(input, 5, stdin);
printf("user input: %s\n", input);
```
Εάν εισάγουμε στην κονσόλα `hello` γίνεται printed το εξής:
```
hell
```
Βλέπουμε ότι παρόλο που είπαμε να διαβάσει 5 χαρακτήρες δεν διάβασε τον
τελευταίο. Αυτό σημβαίνει γιατί στην πραγματικότητα διαβάζει έναν
χαρακτήρα λιγότερο από τον αριθμό που δηλώσαμε με στόχο να παραμείνει ο
τελευταίος ως `\0`. Δηλαδή:
