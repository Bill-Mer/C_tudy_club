# strings; string.h; fgets()
## strings
Στην C τα strings ειναι char arrays και μπορούν να γίνουν printed στην οθόνη με
τη χρήση του `%s`
```c
char s1[] = {'h', 'e', 'l', 'l', 'o'};
printf("%s\n", s1);
```
```
hello
```
Θα μπορούσαμε να ορίσουμε πιο γρήγορα ένα string ως εξής:
```c
char s2[] = "hello";
```
Παρατηρήστε ότι σε αυτή τη περίπτωση χρησιμοποιήθηκαν διπλά εισαγωγικά `""`
αντί για μονά `''`. Τα μονά εισαγωγικά περιέχουν **πάντα 1 μόνο char**, ενώ τα
διπλά εισαγωγικά περιέχουν **πάντα ένα string**.

Μία ακόμη διαφορά είναι ότι το μέγεθος του `s1` είναι `5 * 1 = 5` bytes ενώ το
μέγεθος του `s2` είναι `6 * 1 = 6` bytes, όπου το `5` γίνεται `6` γιατί
αναπαριστά το μέγεθος του τερματικού χαρακτήρα `\0`. Ο τερματικός χαρακτήρας
υποδηλώνει πού τελειώνει ένα string. Θα μπορούσαμε να εισάγουμε το `\0` πιο
νωρίς σε ένα string για να το τερματίσουμε στη μέση του.
```c
char s3[] = "Hello World!";
printf("whole string: %s\n", s3);
s3[5] = '\0';
printf("truncated string: %s\n", s3);
```
```
whole string: Hello World!
truncated string: Hello
```

Εάν δεν αρχικοποιήσουμε το string με κάποιον από τους δύο τρόπους κατά τον
ορισμό του, δεν θα μπορούμε πιο μετά στον κώδικα να του δώσουμε μια τιμή με τη
χρήση του γρήγορου τρόπου:
```c
char s4[5];
s4 = "hello";  // raises error
```
```
error: assignment to expression with array type
```
Ο πρώτος προφανής τρόπος για να αρχικοποιήσουμε ένα ήδη ορισμένο string είναι
να γεμίσουμε τις τιμές του σαν να είναι πίνακας.
```c
char s4[5];
s4[0] = 'h';
s4[1] = 'e';
s4[2] = 'l';
s4[3] = 'l';
s4[4] = 'o';
printf("%s\n", s4);
```
```
hello
```
Αλλά, επειδή αυτός ο τρόπος είναι πολύ αργός και καθόλου πρακτικός, γεννάται η
ανάγκη ύπαρξης μιας συνάρτησης που θα κάνει αυτή τη δουλειά αυτόματα.

## string.h
Η `string.h` είναι μια βιβλιοθήκη που περιέχει χρήσιμες συναρτήσεις που
διευκολύνουν την διαχείρηση strings. Για να μπορέσουμε να τις χρησιμοποιήσουμε
πρέπει να προσθέσουμε `#include <string.h>` στην αρχή του κώδικα.

### strcpy
Για να αντιγράψουμε την τιμή `hello` στη μεταβλητή `s` μπορούμε να
χρησιμοποιήσουμε τη συνάρτηση `strcpy()` - string copy. Ωστόσο πρέπει να
προσέξουμε το εξής: Η `strcpy` κάνει την αντιγραφή των χαρακτήρων έναν προς
έναν, αλλά στο τέλος γράφει και τον τερματικό χαρακτήρα `\0` και γι' αυτό θα
χρειαστούμε η μεταβλητή να είναι μεγέθους 6 bytes αντί για 5, δηλαδή όσο το
μήκος του string που θέλουμε να αντιγράψουμε συν 1.
```c
char s[6];
strcpy(s, "hello");
printf("%s\n", s);
```
```
hello
```
H `strcpy` μπορεί να πάρει ως δεύτερο όρισμα και μια άλλη μεταβλητή:
`strcpy(dest, src)`. Στην ουσία, αντιγράφει τα δεδομένα της πηγής `src` στον
προορισμό `dest`.

### strcmp
Η `strcmp(str1, str2)` συγκρίνει αλφαβητικά δύο strings `str1` και `str2` και
εάν είναι ίδια επιστρέφει `0`.
```c
int comparison;
comparison = strcmp("hello", "hello");
printf("%d\n", comparison);
```
```
0
```
Μπορούμε να συμπτύξουμε των κώδικα σε μια γραμμή:
```c
printf("%d\n", strcmp("hello", "hello"));
```
Όταν τα strings είναι διαφορετικά, ο αριθμός που επιστρέφει η συνάρτηση μας
δίνει πληροφορίες για το ποιο από τα δύο προηγείται αλφαβητικά.
```c
printf("%d\n", strcmp("aaa", "bbb"));
```
```
-1
```
To αποτέλεσμα είναι αρνητικό όταν προηγείται το πρώτο string και θετικό όταν
προηγείται το δεύτερο.

> *reality check:*
>
> Δημιούργησε ένα πρόγραμμα στο οποίο θα αρχικοποιούνται δύο strings, και με τη
> χρήση της `strcmp` το πρόγραμμα θα αναφέρει ποιο από τα δύο προηγείται
> αλφαβητικά. Άλλαξε τις αρχικές τιμές των strings ώστε να εμφανιστούν όλες οι
> πιθανές αναφορές.
>
> <details>
>  <summary>solution</summary>
>  
>  ```c
>  char str1[] = "apple";  // try to change it to "cherry" later
>  char str2[] = "banana";
>
>  if (strcmp(str1, str2) > 0) {
>      printf("%s comes after %s\n", str1, str2);
>  } else if (strcmp(str1, str2) < 0) {
>      printf("%s comes before %s\n", str1, str2);
>  } else {
>      printf("%s is the same as %s\n", str1, str2);
>  }
>  ```
> </details>

## fgets()
Με την `fgets` μπορούμε να λάβουμε input από τον χρήστη. Οι παράμετροι που
δέχεται είναι τρεις:

`char*`: Η μεταβλητή στην οποία θα αποθηκευτεί το input.

`int`: Ο μέγιστος αριθμός χαρακτήρων που θα διαβάσει. Η `fgets` μπορεί να
διαβάσει και λιγότερους χαρακτήρες αν ο χρήστης πατήσει πιο νωρίς `Enter`.

`FILE*`: Το αρχείο που θα διαβάσει. Εάν θέλουμε να διαβάσει το input του χρήστη
τότε απλά βάζουμε `stdin`. Θα δούμε ότι η `fgets` μπορεί να διαβάσει και αρχεία
κειμένου.
```c
char input[5];
fgets(input, 5, stdin);
printf("user input: %s\n", input);
```
Εάν εισάγουμε στην κονσόλα `hello` γίνεται printed το εξής:
```
user input: hell
```
Βλέπουμε ότι παρόλο που είπαμε να διαβάσει 5 χαρακτήρες δεν διάβασε τον
τελευταίο. Αυτό συμβαίνει γιατί στην πραγματικότητα διαβάζει έναν χαρακτήρα
λιγότερο από τον αριθμό που δηλώσαμε με στόχο να παραμείνει ο τελευταίος ως
`\0`. Δηλαδή: διαβάζει το πολύ όσους χαρκτήρες δηλώσαμε πλην 1 έτσι ώστε να
χωρέσει να μπει στο τέλος του string ο τερματικός χαρακτήρας `\0`. Όλα τα
strings τελειώνουν με τερματικό χαρακτήρα, εκτός από αυτά που η δήλωσή τους
έγινε σαν ένας πίνακας (πχ. `char str[2] = {'h', 'i'}`)

Επίσης μπορούμε να παρατηρήσουμε ότι αν πατήσουμε `Enter` έχοντας γράψει
λιγότερους χαρακτήρες στην κονσόλα, στη μεταβλητή θα αποθηκευτούν οι
χαρακτήρες μέχρι και τον χαρακτήρα της νέας γραμμής `\n`.
```c
char input[5];
fgets(input, 5, stdin);
printf("user input: %s\n", input);
```
Εάν εισάγουμε `hi` στην κονσόλα:
```
user input: hi

```
Εάν αλλάξουμε λίγο την `printf` βάζοντας μια παύλα στην αρχή και στο τέλος του
input θα μπορέσουμε να κάνουμε μια ενδιαφέρουσα παρατήρηση.
```c
char input[10];
fgets(input, 10, stdin);
printf("user input: -%s-\n", input);
```
Εάν εισάγουμε `hello` στην κονσόλα:
```
user input: -hellο
-
```
Μπορούμε να δούμε ότι μέσα στο input του χρήστη αποθηκεύτηκε και ο χαρακτήρας
της καινούργιας γραμμής `\n`! Αυτό συμβαίνει γιατί όταν ο χρήστης θέλει να
περάσει το input `hello` πατάει `Enter`, όμως το `Enter` συνδεδεμένο με τον
χαρακτήρα `\n`. Αυτό όμως δημιουργεί πρόβλημα. Για να το προσπεράσουμε,
μπορούμε όταν πάρουμε το string που ξέρουμε ότι μπορεί να περιέχει το `\n`,
να δημιουργήσουμε ένα for-loop που θα ψάχνει να το βρει και όταν το βρει να το
αντικαταστήσει με τον τερματικό χαρακτήρα `\0`.
```c
for (int i=0; i<10; i++) {
    if (input[i] == '\n') {
        input[i] = '\0';
        break;
    }
}
```
Αυτός ο κώδικας θα πάρει το input, που έστω ότι έχει τη μορφή
`{'h', 'i', '\n', '\0'}` και θα αντικαταστήσει το `\n` με `\0`, τερματίζοντας
νωρίτερα το string. Το τελικό string θα μοιάζει με: `{'h', 'i', '\0', '\0'}`.
Δεν μας ενοχλεί η ύπαρξη δύο `\0`, καθώς ο compiler δεν νοιάζεται για το τι
υπάρχει μετά το πρώτο `\0`.

**Γενικά, προτείνεται να  διαβάζετε με την fgets περισσότερους χαρακτήρες από
αυτό που αναμένετε να εισάγει ο χρήστης, και απλά στο τέλος να αντικαθηστάτε
το `\n` με `\0`.**

Όλος ο κώδικας για την την υποδοχή input από τον χρήστη:
```c
char input[50];
fgets(input, 50, stdin);
for (int i=0; i<50; i++) {
    if (input[i] == '\n') {
        input[i] = '\0';
        break;
    }
}
printf("user input: -%s-\n);
```
Εάν εισάγουμε `hello` στην κονσόλα:
```
user input: -hello-
```
Παρατηρήστε ότι ρυθμίσαμε την `fgets` να διαβάσει μέχρι `50` χαρακτήρες,
δηλαδή πολλούς περισσότερους από αυτό που περιμέναμε να εισαχθούν. Better safe
than sorry!